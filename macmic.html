<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mic → Speaker ループ + デュアルタイマー</title>
  <style>
    :root { --bg:#0b0c10; --fg:#eaf0f6; --muted:#8aa0b5; --card:#16181d; }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--fg); margin:0;}
    header{padding:18px 20px; border-bottom:1px solid #23262d; position:sticky; top:0; background:linear-gradient(180deg, rgba(22,24,29,.98), rgba(22,24,29,.92)); backdrop-filter: blur(8px);} 
    h1{font-size:18px; margin:0 0 6px}
    .sub{color:var(--muted); font-size:13px}
    main{max-width:880px; margin:0 auto; padding:18px}
    .card{background:var(--card); border:1px solid #262a31; border-radius:14px; padding:16px; margin:12px 0;}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
    label{font-size:13px; color:var(--muted)}
    select, button, input[type="range"], input[type="checkbox"], input[type="number"]{background:#0f1116; color:var(--fg); border:1px solid #2c323c; border-radius:10px; padding:10px; font-size:14px}
    input[type="number"]{width:90px}
    select{min-width:260px}
    button{cursor:pointer}
    button.primary{background:#105fd4; border-color:#1360c3}
    button.ghost{background:#0f1116}
    button:disabled{opacity:.6; cursor:not-allowed}
    .meters{display:flex; align-items:flex-end; gap:4px; height:90px;}
    .bar{width:8px; background:#2f3743; border-radius:6px; overflow:hidden}
    .bar > i{display:block; width:100%; height:8%; background:#3ddc84}
    .danger > i{background:#ff5555}
    .hint{font-size:12px; color:var(--muted)}
    .spacer{flex:1}
    /* Timer UI */
    .timers{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    .timer{background:#10131a; border:1px solid #262a31; border-radius:12px; padding:12px}
    .timer h3{margin:0 0 8px; font-size:14px; color:#8aa0b5}
    .time-inputs{display:flex; gap:8px; align-items:center}
    .bigtime{font-variant-numeric:tabular-nums; font-size:32px; letter-spacing:1px; margin-top:8px}
    .done{animation: blink 1s step-start 6}
    @keyframes blink {50%{opacity:.3}}
  </style>
</head>
<body>
  <header>
    <h1>Mic → Speaker ループ</h1>
    <div class="sub">マイク入力をそのままスピーカーに出力（ブラウザのみ / ローカル）。ハウリング防止にヘッドホン推奨。</div>
  </header>
  <main>
    <!-- Audio Loop Section -->
    <section class="card">
      <div class="row" style="gap:16px">
        <div>
          <label for="micSel">マイク</label><br />
          <select id="micSel"></select>
        </div>
        <div>
          <label for="spkSel">スピーカー（対応ブラウザのみ）</label><br />
          <select id="spkSel" disabled></select>
        </div>
        <div class="spacer"></div>
        <div class="row">
          <button id="startBtn" class="primary">▶︎ 開始</button>
          <button id="stopBtn" class="ghost" disabled>■ 停止</button>
        </div>
      </div>
      <div class="row" style="margin-top:12px">
        <label><input type="checkbox" id="muteChk" /> ミュート</label>
        <label>音量 <input type="range" id="gainSlider" min="0" max="200" value="100" /></label>
        <label>遅延 <input type="range" id="delaySlider" min="0" max="300" value="0" /> <span class="hint" id="delayVal">0 ms</span></label>
        <label><input type="checkbox" id="echoChk" checked /> echoCancellation</label>
        <label><input type="checkbox" id="nsChk" checked /> noiseSuppression</label>
        <label><input type="checkbox" id="agcChk" /> autoGainControl</label>
      </div>
    </section>

    <section class="card">
      <div style="display:flex; gap:18px; align-items:center">
        <div>
          <div class="hint">レベルメーター</div>
          <div class="meters" id="meters"></div>
        </div>
        <div class="hint">⚠️ 内蔵スピーカーでループするとハウリングが起きやすいです。音量・遅延で調整してください。</div>
      </div>
    </section>

    <!-- Dual Timers Section -->
    <section class="card">
      <div class="row" style="gap:12px; align-items:center">
        <h2 style="margin:0;font-size:16px">デュアルタイマー</h2>
        <div class="spacer"></div>
        <button id="tStartBoth" class="primary">▶︎ 同時開始</button>
        <button id="tPauseBoth" class="ghost">⏸ 一時停止 / 再開</button>
        <button id="tResetBoth" class="ghost">↺ リセット</button>
      </div>
      <div class="timers" style="margin-top:12px">
        <div class="timer" id="timerA">
          <h3>タイマー A</h3>
          <div class="time-inputs">
            <label>分 <input type="number" id="taMin" min="0" value="0"></label>
            <label>秒 <input type="number" id="taSec" min="0" max="3599" value="30"></label>
            <button id="taSet" class="ghost">設定</button>
          </div>
          <div class="bigtime" id="taDisp">00:30.0</div>
        </div>
        <div class="timer" id="timerB">
          <h3>タイマー B（カウントアップ）</h3>
          <div class="hint">開始すると 0:00.0 から増えていきます。停止またはリセットでクリア。</div>
          <div class="bigtime" id="tbDisp">00:00.0</div>
        </div>
      </div>
      <div class="hint" style="margin-top:8px">同時開始ボタンで2つを同時にスタート。一時停止は両方に効きます。終了時は軽いビープ音（ユーザー操作後のみ再生可）。</div>
    </section>
  </main>

  <audio id="monitor" autoplay playsinline></audio>

  <script>
    // ===== Mic → Speaker monitor =====
    const micSel = document.getElementById('micSel');
    const spkSel = document.getElementById('spkSel');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const muteChk = document.getElementById('muteChk');
    const gainSlider = document.getElementById('gainSlider');
    const delaySlider = document.getElementById('delaySlider');
    const delayVal = document.getElementById('delayVal');
    const echoChk = document.getElementById('echoChk');
    const nsChk = document.getElementById('nsChk');
    const agcChk = document.getElementById('agcChk');
    const audioEl = document.getElementById('monitor');

    let audioCtx, stream, source, analyser, gainNode, delayNode, dest, rafId;

    async function enumerate() {
      const devs = await navigator.mediaDevices.enumerateDevices();
      micSel.innerHTML = '';
      spkSel.innerHTML = '';
      for (const d of devs) {
        if (d.kind === 'audioinput') {
          const opt = document.createElement('option');
          opt.value = d.deviceId; opt.textContent = d.label || `マイク (${d.deviceId.slice(0,4)}…)`;
          micSel.appendChild(opt);
        }
        if (d.kind === 'audiooutput') {
          const opt = document.createElement('option');
          opt.value = d.deviceId; opt.textContent = d.label || `スピーカー (${d.deviceId.slice(0,4)}…)`;
          spkSel.appendChild(opt);
        }
      }
      if (typeof audioEl.sinkId !== 'undefined' && spkSel.options.length) {
        spkSel.disabled = false;
      } else {
        spkSel.disabled = true;
      }
    }

    function buildNodes() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      source = audioCtx.createMediaStreamSource(stream);
      gainNode = audioCtx.createGain();
      delayNode = audioCtx.createDelay(1.0); // up to 1s
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 256;
      dest = audioCtx.createMediaStreamDestination();

      source.connect(gainNode);
      gainNode.connect(delayNode);
      delayNode.connect(analyser);
      analyser.connect(dest);

      audioEl.srcObject = dest.stream; // route into <audio>
    }

    function updateGain() {
      const v = Number(gainSlider.value) / 100;
      if (gainNode) gainNode.gain.value = muteChk.checked ? 0 : v;
    }

    function updateDelay() {
      const ms = Number(delaySlider.value);
      delayVal.textContent = `${ms} ms`;
      if (delayNode) delayNode.delayTime.value = ms / 1000;
    }

    function drawMeter() {
      const meters = document.getElementById('meters');
      meters.innerHTML = '';
      const bars = Array.from({length:16}, () => {
        const b = document.createElement('div');
        b.className = 'bar';
        const i = document.createElement('i');
        b.appendChild(i);
        meters.appendChild(b);
        return i;
      });
      const data = new Uint8Array(analyser.frequencyBinCount);
      const loop = () => {
        if (!analyser) return; // closed
        analyser.getByteFrequencyData(data);
        for (let i=0;i<bars.length;i++){
          const v = data[i] / 255;
          const h = Math.max(6, Math.round(v * 90));
          bars[i].style.height = h + '%';
          const parent = bars[i].parentElement;
          if (v > 0.85) parent.classList.add('danger'); else parent.classList.remove('danger');
          bars[i].style.transform = `scaleY(${v*1.0 + 0.06})`;
        }
        rafId = requestAnimationFrame(loop);
      };
      loop();
    }

    async function start() {
      startBtn.disabled = true;
      stopBtn.disabled = false;
      const constraints = {
        audio: {
          deviceId: micSel.value ? { exact: micSel.value } : undefined,
          echoCancellation: echoChk.checked,
          noiseSuppression: nsChk.checked,
          autoGainControl: agcChk.checked,
          channelCount: 1,
          sampleRate: 48000
        }
      };
      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        buildNodes();
        updateGain();
        updateDelay();
        drawMeter();
        await enumerate();
        if (typeof audioEl.sinkId !== 'undefined' && spkSel.value) {
          try { await audioEl.setSinkId(spkSel.value); } catch(e){ console.warn('setSinkId failed', e); }
        }
      } catch (e) {
        console.error(e);
        alert('マイクの取得に失敗しました: ' + e.message);
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    function stop() {
      startBtn.disabled = false;
      stopBtn.disabled = true;
      if (rafId) cancelAnimationFrame(rafId);
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
      audioEl.srcObject = null;
    }

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
    muteChk.addEventListener('change', updateGain);
    gainSlider.addEventListener('input', updateGain);
    delaySlider.addEventListener('input', updateDelay);
    spkSel.addEventListener('change', async () => {
      if (typeof audioEl.sinkId !== 'undefined') {
        try { await audioEl.setSinkId(spkSel.value); } catch(e){ alert('出力デバイスの切替に失敗: '+e.message); }
      }
    });

    // Prefetch labels (permission prompt) then enumerate
    navigator.mediaDevices.getUserMedia({audio:true}).then(s=>{
      s.getTracks().forEach(t=>t.stop());
      enumerate();
    }).catch(()=>enumerate());

    // ===== Dual Timers =====
    const tStartBoth = document.getElementById('tStartBoth');
    const tPauseBoth = document.getElementById('tPauseBoth');
    const tResetBoth = document.getElementById('tResetBoth');

    const taMin = document.getElementById('taMin');
    const taSec = document.getElementById('taSec');
    const taSet = document.getElementById('taSet');
    const taDisp = document.getElementById('taDisp');
    const tbDisp = document.getElementById('tbDisp');

    let timerRAF = null;
    let baseNow = 0; // performance.now() at (re)start
    let paused = true;

    const T = {
      // A: countdown
      A: { totalMs: 30_000, remainMs: 30_000, done: false, el: taDisp, box: document.getElementById('timerA') },
      // B: count-up
      B: { elapsedMs: 0, done: false, el: tbDisp, box: document.getElementById('timerB') },
    };

    function fmt(ms){
      ms = Math.max(0, Math.round(ms));
      const m = String(Math.floor(ms/60000)).padStart(2,'0');
      const s = String(Math.floor((ms%60000)/1000)).padStart(2,'0');
      const t = String(Math.floor((ms%1000)/100));
      return `${m}:${s}.${t}`;
    }

    function updateDisplays(){
      T.A.el.textContent = fmt(T.A.remainMs);
      T.B.el.textContent = fmt(T.B.elapsedMs);
    }

    function beep(){
      try{
        const ctx = (window.__beepCtx && window.__beepCtx.state!=='closed') ? window.__beepCtx : new (window.AudioContext||window.webkitAudioContext)();
        window.__beepCtx = ctx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(880, ctx.currentTime);
        g.gain.setValueAtTime(0.0001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime+0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.5);
        o.connect(g).connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime+0.5);
      }catch(e){ /* ignore */ }
    }

    function tick(){
      if(paused){ return; }
      const now = performance.now();
      const delta = now - baseNow;
      baseNow = now;
      // A: countdown, B: count-up
      // A (countdown)
      const a = T.A;
      if(!a.done){
        a.remainMs -= delta;
        if(a.remainMs <= 0){
          a.remainMs = 0;
          a.done = true;
          a.box.classList.add('done');
          beep();
        }
      }
      // B (count-up)
      const b = T.B;
      if(!b.done){
            b.elapsedMs += delta;
        }
        updateDisplays();
        timerRAF = requestAnimationFrame(tick);
    }


    function startBoth(){
      if(!paused) return; // already running
      paused = false;
      baseNow = performance.now();
      // clear done state visuals
      T.A.box.classList.remove('done');
      T.B.box.classList.remove('done');
      if (timerRAF) cancelAnimationFrame(timerRAF);
      timerRAF = requestAnimationFrame(tick);
    }

    function pauseBoth(){
      paused = !paused;
      if(!paused){
        baseNow = performance.now();
        if (timerRAF) cancelAnimationFrame(timerRAF);
        timerRAF = requestAnimationFrame(tick);
      }
    }

    function resetBoth(){
      paused = true;
      if (timerRAF) cancelAnimationFrame(timerRAF);
      // A back to total
      T.A.remainMs = T.A.totalMs;
      T.A.done = false;
      T.A.box.classList.remove('done');
      // B back to zero
      T.B.elapsedMs = 0;
      T.B.done = false;
      T.B.box.classList.remove('done');
      updateDisplays();
    }

    function setFromInputs(){
      const mins = Math.max(0, parseInt(taMin.value||0,10));
      const secs = Math.max(0, parseInt(taSec.value||0,10));
      const ms = (mins*60 + secs) * 1000;
      T.A.totalMs = Math.max(0, ms);
      T.A.remainMs = T.A.totalMs;
      T.A.done = false;
      T.A.box.classList.remove('done');
      updateDisplays();
    }

    tStartBoth.addEventListener('click', startBoth);
    tPauseBoth.addEventListener('click', pauseBoth);
    tResetBoth.addEventListener('click', resetBoth);

    taSet.addEventListener('click', ()=>setFromInputs());
    tbSet.addEventListener('click', ()=>setFromInputs('B'));

    // init displays
    updateDisplays();
  </script>
</body>
</html>
